# Examples: Сценарии тестирования emacs-flash

## MVP функции

### 1. Базовый jump

**Сценарий:** Прыжок к слову по метке

```
Подготовка:
- Открыть буфер с текстом: "foo bar baz foo bar baz"
- Курсор в начале буфера

Действия:
1. M-x emacs-flash-jump
2. Набрать "ba"
3. Увидеть метки на всех "ba" (bar, baz)
4. Нажать метку (например 'a')

Ожидание:
- Курсор перемещается к началу выбранного "bar" или "baz"
- Все overlays удалены
```

### 2. Инкрементальный ввод

**Сценарий:** Метки обновляются по мере ввода

```
Подготовка:
- Буфер: "apple application apply apt"

Действия:
1. M-x emacs-flash-jump
2. Набрать "ap" → видим 4 метки
3. Набрать "p" (теперь "app") → видим 3 метки (apt отфильтрован)
4. Набрать "l" (теперь "appl") → видим 2 метки

Ожидание:
- Количество меток уменьшается с каждым символом
- Метки переназначаются корректно
```

### 3. Autojump

**Сценарий:** Автоматический прыжок при единственном совпадении

```
Подготовка:
- Буфер: "unique_word and other text"
- emacs-flash-autojump = t

Действия:
1. M-x emacs-flash-jump
2. Набрать "unique"

Ожидание:
- Автоматически прыгает к "unique_word" без выбора метки
- Сессия завершается
```

### 4. Отмена (ESC)

**Сценарий:** Отмена возвращает курсор

```
Подготовка:
- Буфер с текстом, курсор на строке 10

Действия:
1. M-x emacs-flash-jump
2. Набрать "foo"
3. Нажать ESC

Ожидание:
- Курсор возвращается на строку 10
- Все overlays удалены
- Окно не изменилось
```

### 5. Backspace

**Сценарий:** Удаление символа из паттерна

```
Подготовка:
- Буфер: "foo food foot"

Действия:
1. M-x emacs-flash-jump
2. Набрать "food" → 1 совпадение
3. Нажать Backspace → паттерн "foo" → 3 совпадения
4. Нажать Backspace → паттерн "fo" → 3 совпадения

Ожидание:
- Паттерн укорачивается
- Совпадения пересчитываются
```

### 6. Enter — прыжок к первому

**Сценарий:** RET прыгает к ближайшему совпадению

```
Подготовка:
- Буфер: "target ... target ... target"
- Курсор в середине

Действия:
1. M-x emacs-flash-jump
2. Набрать "target"
3. Нажать RET

Ожидание:
- Прыжок к ближайшему "target" (не обязательно первому в буфере)
```

### 7. Multi-window

**Сценарий:** Поиск во всех видимых окнах

```
Подготовка:
- Два окна: window-A с "hello", window-B с "hello world"
- Курсор в window-A
- emacs-flash-multi-window = t

Действия:
1. M-x emacs-flash-jump
2. Набрать "hello"

Ожидание:
- Метки появляются в ОБОИХ окнах
- Можно прыгнуть в window-B, выбрав соответствующую метку
- После прыжка активным становится window-B
```

### 8. Backdrop

**Сценарий:** Затемнение фона

```
Подготовка:
- Буфер с текстом
- emacs-flash-backdrop = t

Действия:
1. M-x emacs-flash-jump
2. Набрать несколько символов

Ожидание:
- Весь текст кроме совпадений затемнён (face emacs-flash-backdrop)
- Совпадения выделены ярко (face emacs-flash-match)
- Метки хорошо видны (face emacs-flash-label)
```

### 9. Пропуск конфликтных меток

**Сценарий:** Метки не конфликтуют с паттерном

```
Подготовка:
- Буфер: "ab ac ad ae af"
- emacs-flash-labels начинается с "a..."

Действия:
1. M-x emacs-flash-jump
2. Набрать "a"

Ожидание:
- Метка 'a' НЕ используется (конфликтует с "ab", "ac", ...)
- Метка 'b' НЕ используется (конфликтует с "ab")
- Используются метки, которые не могут продолжить паттерн
```

### 10. Нет совпадений

**Сценарий:** Поведение при отсутствии совпадений

```
Подготовка:
- Буфер: "hello world"

Действия:
1. M-x emacs-flash-jump
2. Набрать "xyz"

Ожидание:
- Нет меток (нет совпадений)
- Backdrop показывает весь текст затемнённым
- Можно продолжить ввод или нажать ESC/Backspace
```

---

## Расширенные функции (Phase 4)

### 11. Evil-mode интеграция

**Сценарий:** Использование с evil operator

```
Подготовка:
- evil-mode активен
- Буфер: "delete this word and keep rest"

Действия:
1. Нажать 'd' (delete operator в evil)
2. M-x emacs-flash-jump (или keybinding)
3. Набрать "word"
4. Выбрать метку

Ожидание:
- Текст от курсора до "word" удалён
- Работает как motion для evil operators
```

### 12. Rainbow labels

**Сценарий:** Разноцветные метки

```
Подготовка:
- emacs-flash-rainbow = t
- Много совпадений в буфере

Действия:
1. M-x emacs-flash-jump
2. Набрать паттерн с 10+ совпадениями

Ожидание:
- Метки разных цветов для лучшей различимости
- Цвета помогают группировать близкие метки
```

### 13. Case-fold

**Сценарий:** Регистронезависимый поиск

```
Подготовка:
- Буфер: "Hello HELLO hello HeLLo"
- emacs-flash-case-fold = t

Действия:
1. M-x emacs-flash-jump
2. Набрать "hello"

Ожидание:
- Все 4 варианта найдены и помечены
```

---

## Edge Cases

### 14. Пустой паттерн

**Сценарий:** Поведение без ввода

```
Действия:
1. M-x emacs-flash-jump
2. Сразу нажать ESC (без ввода)

Ожидание:
- Сессия завершается без ошибок
- Курсор не двигается
```

### 15. Очень длинный паттерн

**Сценарий:** Паттерн длиннее любого слова

```
Подготовка:
- Буфер: "short words only"

Действия:
1. M-x emacs-flash-jump
2. Набрать "verylongpattern"

Ожидание:
- Нет совпадений
- Нет ошибок
- Backspace работает
```

### 16. Спецсимволы в паттерне

**Сценарий:** Поиск спецсимволов

```
Подготовка:
- Буфер: "func() and func[] and func{}"

Действия:
1. M-x emacs-flash-jump
2. Набрать "func("

Ожидание:
- Находит "func(" литерально
- Скобка не интерпретируется как regex
```

### 17. Узкий регион (narrowing)

**Сценарий:** Работа с narrowed buffer

```
Подготовка:
- Буфер сужен до части текста (narrow-to-region)

Действия:
1. M-x emacs-flash-jump
2. Набрать паттерн

Ожидание:
- Поиск только в видимой (narrowed) части
- Или: поиск во всём буфере? (решить)
```

### 18. Folded regions

**Сценарий:** Работа со свёрнутыми блоками

```
Подготовка:
- Буфер с org-mode или outline-mode
- Часть текста свёрнута

Вопрос (Open Question):
- Искать в свёрнутых регионах?
- Разворачивать при прыжке?
```
